# configai 集成指南

> 本文档提供 configai REST API 的完整集成参考。AI 助手可据此为任意语言生成集成代码。

## API 概览

| 端点 | 方法 | 说明 |
|------|------|------|
| `/api/v1/projects/{project}/envs/{env}/configs` | GET | 全部配置（JSON + env_vars） |
| `/api/v1/projects/{project}/envs/{env}/configs/{key}` | GET | 单个配置项 |
| `/api/v1/projects/{project}/envs/{env}/export?prefix={P}` | GET | shell export 格式（纯文本） |

## 认证

所有请求必须携带 `X-API-Key` 请求头：
```
X-API-Key: 550e8400-e29b-41d4-a716-446655440000
```

## 响应格式

### 全部配置
```json
{
  "project": "my-app",
  "environment": "prod",
  "configs": {
    "db_host": "localhost",
    "db_port": 5432,
    "debug": false,
    "allowed_origins": ["https://example.com"],
    "retry": {"max_retries": 3, "backoff_ms": 1000}
  },
  "env_vars": {
    "DB_HOST": "localhost",
    "DB_PORT": 5432,
    "DEBUG": false,
    "ALLOWED_ORIGINS": ["https://example.com"],
    "RETRY": {"max_retries": 3, "backoff_ms": 1000}
  }
}
```

### 单个配置项
```json
{"key": "db_host", "value": "localhost"}
```

值可以是任意 JSON 类型：字符串、数字、布尔、null、数组、对象。

### 环境变量导出
```
export DB_HOST=localhost
export DB_PORT=5432
export DEBUG=false
export ALLOWED_ORIGINS="[\"https://example.com\"]"
```

带前缀 `?prefix=MY_APP`:
```
export MY_APP_DB_HOST=localhost
export MY_APP_DB_PORT=5432
```

## 环境变量转换规则

| 原始 key | 转换后 | 规则 |
|----------|--------|------|
| `db_host` | `DB_HOST` | 大写 |
| `redis.url` | `REDIS_URL` | 点→下划线 |
| `api-timeout` | `API_TIMEOUT` | 横线→下划线 |
| `"hello world"` | `"hello world"` | 字符串原样 |
| `5432` | `5432` | 数字转字符串 |
| `true` | `true` | 布尔转字符串 |
| `["a","b"]` | `["a","b"]` | 数组保持原始类型 |
| `{"k":"v"}` | `{"k":"v"}` | 对象保持原始类型 |

## 错误处理

| HTTP 状态码 | 含义 | 响应体 |
|------------|------|--------|
| 401 | 缺少或无效 API Key | `{"error": "missing X-API-Key header"}` 或 `{"error": "invalid api key"}` |
| 403 | Key 无权访问该项目 | `{"error": "api key not authorized for project: xxx"}` |
| 404 | 资源不存在 | `{"error": "project not found: xxx"}` / `{"error": "environment not found: xxx"}` / `{"error": "config item not found: xxx"}` |

## 集成代码示例

### Shell / Bash
```bash
# 读取全部配置
curl -s -H "X-API-Key: $CONFIG_KEY" \
  http://configai:3000/api/v1/projects/my-app/envs/prod/configs | jq .configs

# 读取单个值
DB_HOST=$(curl -s -H "X-API-Key: $CONFIG_KEY" \
  http://configai:3000/api/v1/projects/my-app/envs/prod/configs/db_host | jq -r .value)

# 注入环境变量
source <(curl -s -H "X-API-Key: $CONFIG_KEY" \
  http://configai:3000/api/v1/projects/my-app/envs/prod/export)

# 带前缀注入
source <(curl -s -H "X-API-Key: $CONFIG_KEY" \
  "http://configai:3000/api/v1/projects/my-app/envs/prod/export?prefix=MY_APP")
```

### Python
```python
import requests

CONFIGAI_URL = "http://configai:3000"
API_KEY = "your-api-key"
HEADERS = {"X-API-Key": API_KEY}

# 获取全部配置
def get_config(project: str, env: str) -> dict:
    resp = requests.get(
        f"{CONFIGAI_URL}/api/v1/projects/{project}/envs/{env}/configs",
        headers=HEADERS,
    )
    resp.raise_for_status()
    return resp.json()["configs"]

# 获取单个配置项
def get_config_item(project: str, env: str, key: str):
    resp = requests.get(
        f"{CONFIGAI_URL}/api/v1/projects/{project}/envs/{env}/configs/{key}",
        headers=HEADERS,
    )
    resp.raise_for_status()
    return resp.json()["value"]

# 获取环境变量映射
def get_env_vars(project: str, env: str, prefix: str | None = None) -> dict[str, str]:
    params = {"prefix": prefix} if prefix else {}
    resp = requests.get(
        f"{CONFIGAI_URL}/api/v1/projects/{project}/envs/{env}/configs",
        headers=HEADERS,
        params=params,
    )
    resp.raise_for_status()
    return resp.json()["env_vars"]

# 使用
config = get_config("my-app", "prod")
db_host = config["db_host"]
db_port = config["db_port"]
```

### Node.js / TypeScript
```typescript
const CONFIGAI_URL = "http://configai:3000";
const API_KEY = "your-api-key";

async function getConfig(project: string, env: string): Promise<Record<string, any>> {
  const resp = await fetch(
    `${CONFIGAI_URL}/api/v1/projects/${project}/envs/${env}/configs`,
    { headers: { "X-API-Key": API_KEY } }
  );
  if (!resp.ok) throw new Error(`configai error: ${resp.status}`);
  const data = await resp.json();
  return data.configs;
}

async function getConfigItem(project: string, env: string, key: string): Promise<any> {
  const resp = await fetch(
    `${CONFIGAI_URL}/api/v1/projects/${project}/envs/${env}/configs/${key}`,
    { headers: { "X-API-Key": API_KEY } }
  );
  if (!resp.ok) throw new Error(`configai error: ${resp.status}`);
  const data = await resp.json();
  return data.value;
}

// 使用
const config = await getConfig("my-app", "prod");
const dbHost = config.db_host;
```

### Go
```go
package configai

import (
	"encoding/json"
	"fmt"
	"net/http"
	"io"
)

type Client struct {
	BaseURL string
	APIKey  string
}

type AllConfigsResponse struct {
	Project     string                 `json:"project"`
	Environment string                 `json:"environment"`
	Configs     map[string]interface{} `json:"configs"`
	EnvVars     map[string]interface{} `json:"env_vars"`
}

func (c *Client) GetConfig(project, env string) (map[string]interface{}, error) {
	url := fmt.Sprintf("%s/api/v1/projects/%s/envs/%s/configs", c.BaseURL, project, env)
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("X-API-Key", c.APIKey)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("configai error %d: %s", resp.StatusCode, body)
	}

	var result AllConfigsResponse
	json.NewDecoder(resp.Body).Decode(&result)
	return result.Configs, nil
}
```

### Rust
```rust
use std::collections::HashMap;
use reqwest::header::HeaderMap;

pub struct ConfigaiClient {
    base_url: String,
    api_key: String,
    client: reqwest::Client,
}

impl ConfigaiClient {
    pub fn new(base_url: &str, api_key: &str) -> Self {
        Self {
            base_url: base_url.to_string(),
            api_key: api_key.to_string(),
            client: reqwest::Client::new(),
        }
    }

    pub async fn get_config(
        &self, project: &str, env: &str,
    ) -> Result<HashMap<String, serde_json::Value>, reqwest::Error> {
        let url = format!(
            "{}/api/v1/projects/{}/envs/{}/configs",
            self.base_url, project, env
        );
        let resp: serde_json::Value = self.client.get(&url)
            .header("X-API-Key", &self.api_key)
            .send().await?
            .json().await?;
        let configs = resp["configs"].as_object().unwrap();
        Ok(configs.iter().map(|(k, v)| (k.clone(), v.clone())).collect())
    }
}
```

### Docker
```dockerfile
# 启动时注入环境变量
CMD source <(curl -s -H "X-API-Key: $CONFIG_KEY" \
  http://configai:3000/api/v1/projects/$PROJECT/envs/$ENV/export) && \
  exec ./my-app
```

### Docker Compose
```yaml
services:
  configai:
    image: configai:latest
    ports:
      - "3000:3000"
    volumes:
      - ./config:/config

  my-app:
    image: my-app:latest
    environment:
      CONFIG_KEY: "your-api-key"
      PROJECT: "my-app"
      ENV: "prod"
    depends_on:
      - configai
```

### Kubernetes
```yaml
# ConfigMap 存放 configai 连接信息
apiVersion: v1
kind: ConfigMap
metadata:
  name: configai-client
data:
  CONFIGAI_URL: "http://configai-service:3000"
  CONFIGAI_PROJECT: "my-app"
  CONFIGAI_ENV: "prod"
---
# Secret 存放 API Key
apiVersion: v1
kind: Secret
metadata:
  name: configai-key
stringData:
  API_KEY: "your-api-key"
---
# Init container 注入配置
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      initContainers:
        - name: load-config
          image: curlimages/curl
          command: ["sh", "-c"]
          args:
            - |
              curl -s -H "X-API-Key: $API_KEY" \
                "$CONFIGAI_URL/api/v1/projects/$CONFIGAI_PROJECT/envs/$CONFIGAI_ENV/export" \
                > /config/env
          envFrom:
            - configMapRef:
                name: configai-client
            - secretRef:
                name: configai-key
          volumeMounts:
            - name: config-vol
              mountPath: /config
      containers:
        - name: app
          command: ["sh", "-c", "source /config/env && exec ./my-app"]
          volumeMounts:
            - name: config-vol
              mountPath: /config
      volumes:
        - name: config-vol
          emptyDir: {}
```
